// Autogenerated code. Do not modify.
package uk.co.trycatchfinallysoftware.data;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import java.util.Date;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Optional;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;
import javax.annotation.Nullable;

/** Auto-generated superclass of {@link Person.Builder}, derived from the API of {@link Person}. */
@Generated("org.inferred.freebuilder.processor.CodeGenerator")
abstract class Person_Builder {

  /** Creates a new builder using {@code value} as a template. */
  public static Person.Builder from(Person value) {
    return new Person.Builder().mergeFrom(value);
  }

  private static final Joiner COMMA_JOINER = Joiner.on(", ").skipNulls();

  private enum Property {
    GENDER("gender"),
    DATE_OF_BIRTH("dateOfBirth"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String firstName;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String middleName = null;
  private String lastName;
  private String gender;
  private Date dateOfBirth;
  private final EnumSet<Person_Builder.Property> _unsetProperties =
      EnumSet.allOf(Person_Builder.Property.class);

  /**
   * Sets the value to be returned by {@link Person#getFirstName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code firstName} is null
   */
  public Person.Builder setFirstName(String firstName) {
    this.firstName = Preconditions.checkNotNull(firstName);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#getFirstName()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   */
  public Person.Builder mapFirstName(UnaryOperator<String> mapper) {
    return setFirstName(mapper.apply(getFirstName()));
  }

  /** Returns the value that will be returned by {@link Person#getFirstName()}. */
  public String getFirstName() {
    return firstName;
  }

  /**
   * Sets the value to be returned by {@link Person#getMiddleName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code middleName} is null
   */
  public Person.Builder setMiddleName(String middleName) {
    this.middleName = Preconditions.checkNotNull(middleName);
    return (Person.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Person#getMiddleName()}.
   *
   * @return this {@code Builder} object
   */
  public Person.Builder setMiddleName(Optional<? extends String> middleName) {
    if (middleName.isPresent()) {
      return setMiddleName(middleName.get());
    } else {
      return clearMiddleName();
    }
  }

  /**
   * Sets the value to be returned by {@link Person#getMiddleName()}.
   *
   * @return this {@code Builder} object
   */
  public Person.Builder setNullableMiddleName(@Nullable String middleName) {
    if (middleName != null) {
      return setMiddleName(middleName);
    } else {
      return clearMiddleName();
    }
  }

  /**
   * If the value to be returned by {@link Person#getMiddleName()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Person.Builder mapMiddleName(UnaryOperator<String> mapper) {
    return setMiddleName(getMiddleName().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Person#getMiddleName()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Person.Builder clearMiddleName() {
    this.middleName = null;
    return (Person.Builder) this;
  }

  /** Returns the value that will be returned by {@link Person#getMiddleName()}. */
  public Optional<String> getMiddleName() {
    return Optional.ofNullable(middleName);
  }

  /**
   * Sets the value to be returned by {@link Person#getLastName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code lastName} is null
   */
  public Person.Builder setLastName(String lastName) {
    this.lastName = Preconditions.checkNotNull(lastName);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#getLastName()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   */
  public Person.Builder mapLastName(UnaryOperator<String> mapper) {
    return setLastName(mapper.apply(getLastName()));
  }

  /** Returns the value that will be returned by {@link Person#getLastName()}. */
  public String getLastName() {
    return lastName;
  }

  /**
   * Sets the value to be returned by {@link Person#getGender()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code gender} is null
   */
  public Person.Builder setGender(String gender) {
    this.gender = Preconditions.checkNotNull(gender);
    _unsetProperties.remove(Person_Builder.Property.GENDER);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#getGender()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Person.Builder mapGender(UnaryOperator<String> mapper) {
    Preconditions.checkNotNull(mapper);
    return setGender(mapper.apply(getGender()));
  }

  /**
   * Returns the value that will be returned by {@link Person#getGender()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getGender() {
    Preconditions.checkState(
        !_unsetProperties.contains(Person_Builder.Property.GENDER), "gender not set");
    return gender;
  }

  /**
   * Sets the value to be returned by {@link Person#getDateOfBirth()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code dateOfBirth} is null
   */
  public Person.Builder setDateOfBirth(Date dateOfBirth) {
    this.dateOfBirth = Preconditions.checkNotNull(dateOfBirth);
    _unsetProperties.remove(Person_Builder.Property.DATE_OF_BIRTH);
    return (Person.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Person#getDateOfBirth()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Person.Builder mapDateOfBirth(UnaryOperator<Date> mapper) {
    Preconditions.checkNotNull(mapper);
    return setDateOfBirth(mapper.apply(getDateOfBirth()));
  }

  /**
   * Returns the value that will be returned by {@link Person#getDateOfBirth()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public Date getDateOfBirth() {
    Preconditions.checkState(
        !_unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH), "dateOfBirth not set");
    return dateOfBirth;
  }

  /** Sets all property values using the given {@code Person} as a template. */
  public Person.Builder mergeFrom(Person value) {
    Person_Builder _defaults = new Person.Builder();
    if (!Objects.equals(value.getFirstName(), _defaults.getFirstName())) {
      setFirstName(value.getFirstName());
    }
    value.getMiddleName().ifPresent(this::setMiddleName);
    if (!Objects.equals(value.getLastName(), _defaults.getLastName())) {
      setLastName(value.getLastName());
    }
    if (_defaults._unsetProperties.contains(Person_Builder.Property.GENDER)
        || !Objects.equals(value.getGender(), _defaults.getGender())) {
      setGender(value.getGender());
    }
    if (_defaults._unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)
        || !Objects.equals(value.getDateOfBirth(), _defaults.getDateOfBirth())) {
      setDateOfBirth(value.getDateOfBirth());
    }
    return (Person.Builder) this;
  }

  /**
   * Copies values from the given {@code Builder}. Does not affect any properties not set on the
   * input.
   */
  public Person.Builder mergeFrom(Person.Builder template) {
    Person_Builder _defaults =
        new Person
            .Builder(); // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Person_Builder base = (Person_Builder) template;
    if (!Objects.equals(template.getFirstName(), _defaults.getFirstName())) {
      setFirstName(template.getFirstName());
    }
    template.getMiddleName().ifPresent(this::setMiddleName);
    if (!Objects.equals(template.getLastName(), _defaults.getLastName())) {
      setLastName(template.getLastName());
    }
    if (!base._unsetProperties.contains(Person_Builder.Property.GENDER)
        && (_defaults._unsetProperties.contains(Person_Builder.Property.GENDER)
            || !Objects.equals(template.getGender(), _defaults.getGender()))) {
      setGender(template.getGender());
    }
    if (!base._unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)
        && (_defaults._unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)
            || !Objects.equals(template.getDateOfBirth(), _defaults.getDateOfBirth()))) {
      setDateOfBirth(template.getDateOfBirth());
    }
    return (Person.Builder) this;
  }

  /** Resets the state of this builder. */
  public Person.Builder clear() {
    Person_Builder _defaults = new Person.Builder();
    firstName = _defaults.firstName;
    middleName = _defaults.middleName;
    lastName = _defaults.lastName;
    gender = _defaults.gender;
    dateOfBirth = _defaults.dateOfBirth;
    _unsetProperties.clear();
    _unsetProperties.addAll(_defaults._unsetProperties);
    return (Person.Builder) this;
  }

  /**
   * Returns a newly-created {@link Person} based on the contents of the {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Person build() {
    Preconditions.checkState(_unsetProperties.isEmpty(), "Not set: %s", _unsetProperties);
    return new Person_Builder.Value(this);
  }

  /**
   * Returns a newly-created partial {@link Person} for use in unit tests. State checking will not
   * be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  @VisibleForTesting()
  public Person buildPartial() {
    return new Person_Builder.Partial(this);
  }

  private static final class Value implements Person {
    private final String firstName;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String middleName;
    private final String lastName;
    private final String gender;
    private final Date dateOfBirth;

    private Value(Person_Builder builder) {
      this.firstName = builder.firstName;
      this.middleName = builder.middleName;
      this.lastName = builder.lastName;
      this.gender = builder.gender;
      this.dateOfBirth = builder.dateOfBirth;
    }

    @Override
    public String getFirstName() {
      return firstName;
    }

    @Override
    public Optional<String> getMiddleName() {
      return Optional.ofNullable(middleName);
    }

    @Override
    public String getLastName() {
      return lastName;
    }

    @Override
    public String getGender() {
      return gender;
    }

    @Override
    public Date getDateOfBirth() {
      return dateOfBirth;
    }

    @Override
    public Person.Builder toBuilder() {
      return new Person.Builder().mergeFrom(this);
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Person_Builder.Value)) {
        return false;
      }
      Person_Builder.Value other = (Person_Builder.Value) obj;
      return Objects.equals(firstName, other.firstName)
          && Objects.equals(middleName, other.middleName)
          && Objects.equals(lastName, other.lastName)
          && Objects.equals(gender, other.gender)
          && Objects.equals(dateOfBirth, other.dateOfBirth);
    }

    @Override
    public int hashCode() {
      return Objects.hash(firstName, middleName, lastName, gender, dateOfBirth);
    }

    @Override
    public String toString() {
      return "Person{"
          + COMMA_JOINER.join(
              "firstName=" + firstName,
              (middleName != null ? "middleName=" + middleName : null),
              "lastName=" + lastName,
              "gender=" + gender,
              "dateOfBirth=" + dateOfBirth)
          + "}";
    }
  }

  private static final class Partial implements Person {
    private final String firstName;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String middleName;
    private final String lastName;
    private final String gender;
    private final Date dateOfBirth;
    private final EnumSet<Person_Builder.Property> _unsetProperties;

    Partial(Person_Builder builder) {
      this.firstName = builder.firstName;
      this.middleName = builder.middleName;
      this.lastName = builder.lastName;
      this.gender = builder.gender;
      this.dateOfBirth = builder.dateOfBirth;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String getFirstName() {
      return firstName;
    }

    @Override
    public Optional<String> getMiddleName() {
      return Optional.ofNullable(middleName);
    }

    @Override
    public String getLastName() {
      return lastName;
    }

    @Override
    public String getGender() {
      if (_unsetProperties.contains(Person_Builder.Property.GENDER)) {
        throw new UnsupportedOperationException("gender not set");
      }
      return gender;
    }

    @Override
    public Date getDateOfBirth() {
      if (_unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)) {
        throw new UnsupportedOperationException("dateOfBirth not set");
      }
      return dateOfBirth;
    }

    private static class PartialBuilder extends Person.Builder {
      @Override
      public Person build() {
        return buildPartial();
      }
    }

    @Override
    public Person.Builder toBuilder() {
      Person.Builder builder = new PartialBuilder();
      builder.setFirstName(firstName);
      builder.setNullableMiddleName(middleName);
      builder.setLastName(lastName);
      if (!_unsetProperties.contains(Person_Builder.Property.GENDER)) {
        builder.setGender(gender);
      }
      if (!_unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)) {
        builder.setDateOfBirth(dateOfBirth);
      }
      return builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Person_Builder.Partial)) {
        return false;
      }
      Person_Builder.Partial other = (Person_Builder.Partial) obj;
      return Objects.equals(firstName, other.firstName)
          && Objects.equals(middleName, other.middleName)
          && Objects.equals(lastName, other.lastName)
          && Objects.equals(gender, other.gender)
          && Objects.equals(dateOfBirth, other.dateOfBirth)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(firstName, middleName, lastName, gender, dateOfBirth, _unsetProperties);
    }

    @Override
    public String toString() {
      return "partial Person{"
          + COMMA_JOINER.join(
              "firstName=" + firstName,
              (middleName != null ? "middleName=" + middleName : null),
              "lastName=" + lastName,
              (!_unsetProperties.contains(Person_Builder.Property.GENDER)
                  ? "gender=" + gender
                  : null),
              (!_unsetProperties.contains(Person_Builder.Property.DATE_OF_BIRTH)
                  ? "dateOfBirth=" + dateOfBirth
                  : null))
          + "}";
    }
  }
}
